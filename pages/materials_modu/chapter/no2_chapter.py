import streamlit as st
from utils.image_loader import get_image_path


code_close='nx.closeness_centrality(G)'
code_between='nx.betweenness_centrality(G)'

def intro():
    st.write("""
             
         ## 第2回（5月?日）
         ### 0.作ったもの紹介
         ### 1.中心性の定義
         ### 2.ネットワークに対するアタック 
         
         """)
    
    st.divider()
    
def chapter0():
    st.header("拡張ランダムウォークモデル")
    
    st.write("""
             前回の発表の残り3分くらいで軽く触れたモデルについて。
             
             ランダムウォークモデルから着想を得たので、便宜上「拡張ランダムウォークモデル」と呼ぶことにする。
             （頑張って探せば同じモデルは既に存在しそうだし、正式名称があればそれに修正します。）
             
             このモデルがなかなかいい振る舞いをするので紹介します。
             
             ＢＡモデルやランダムウォークモデルと違い、接続するノードの数を指定しない。
             つまり新しく追加されたノードは1~lのリンクを得る。
             """)
    image_path=get_image_path("0530_0_1.png")
    st.image(image_path)    
    
    
    st.write("""
             $network0$は$N = 1000,m=10$ のBAモデル。
             
             $network1$は$N=1000,p=0.5,l=100$の拡張ランダムウォークモデル\n
             （以降、exrwモデルと表記）。
             
             BAモデルでは次数0~9のノードが存在しない。スケールフリー性を持つことはいいが、すべての人が最低ｍ人以上の友人がいる前提はいかがなものか。
             
             
             しかしexrwモデルではあるノードが1以上のリンクを持つ上で、スケールフリー性を持っている。
             """)
    
    image_path=get_image_path("0530_0_2.png")
    st.image(image_path) 
    
    st.write("""
             図は$p=0.3,p=0.5,p=0.7$ のexrwモデル
             
             pの値を変えても2割以上のノードは次数2,3,4に集中している。次数の壁は現れない。
             
             
             次数の壁が現れないことがいいことかどうなのかはわからないけど、同じ優先的選択を行うBAモデル、ランダムウォークモデルと明確に異なる性質なので紹介しました。
             
             ここで使用しているヒストグラムはすべてネットワーク保管庫で生成可能！！！。
             """)
    
def chapter1():
    st.header("1.中心性",divider=True)
    st.write("""
             ### 1.1 中心性とは
             
             　ネットワークにおける中心性とは、ネットワーク内でそのノードがどれほど中心的か、あるいは重要であるかを
             示す指標である。後に紹介する「ネットワークに対するのアタック」においても重要な特徴量になる。
             
             
             """)
    st.write("""
             ### 1.2 中心性の種類\n
             
            中心性にはいくつか種類があるが、これから実験を通して扱うことになる中心性を紹介する。
            （さらに新しく中心性を追加する可能性大）
             
            - 次数中心性(degree centrality)
            - 近接中心性(closenes centrality)
            - 媒介中心性(betweenness centreality)

             """)
    
    st.subheader("1.3.1 次数中心性(degree centrality)")
    st.write("""
             社会敵ネットワークにおいて次数とは、ノード（個人）の次数とは、そのノードと他のノードを結ぶ社会的なリンクの数を意味する。
             次数が高い理由が、人気者なのか権力者なのかはわからないが、何らかの意味で重要なのは間違いない。
            
             あるコミュニティにおける重要人物を推定する場合、次数に着目するのは自然な指標と言える。
             
             例：SNSのフォロワー数
             """)
    
    
    st.code('nx.degree_centrality(G,node)',language='python')
    
    st.subheader("1.3.2 近接中心性(closenes centrality)")
    st.write("""
             あるノードが他の（全ての）ノードにどれだけ近いか、
             つまりどれくらいネットワークの中央にいるかを指標としたものが近接中心性である。
             
             他の全てのノードとの距離が短ければ中心性が高いということになる。
             近接中心性はあるノードと他の全てのノードの距離の総和の単純な逆数として定義される。
             
             例：？
             """)
    
    st.code('nx.closeness_centrality(G,node)',language='python')

    st.subheader(" 1.3.3 媒介中心性(betweenness centreality)")
    st.write("""
             あるノードが他の全てのノードのペアの最短経路にどれだけ関与するかを指標としたものが媒介中心性である。
             
             最短経路に多く含まれるノードは媒介中心性が高いということになる。
             また、異なる連結成分を繋ぐ橋の役割を果たすノードは媒介中心性が大きくなる。
             
             例：異なる組織間の情報伝達を担う人物、交通ネットワークにおける主要な交差点。
             """)
    
    st.code('nx.betweenness_centrality(G,node)',language='python')
    
def chapter2():
    st.header("2.ネットワークに対するアタック",divider=True)
    # 概要
    
    st.write("""
             システムの構成要素の一部が故障しても、その機能に影響がない場合、そのシステムは頑健であるという。
             ネットワークの頑健性はどのように定義できるだろうか？
             
             方法の１つはノードとそのリンクを除去したとき、そのネットワーク内での特徴量にどのような影響がでるかを調べることである。
             つまり「システムの一部の故障」を「ノード１つの除去」として再現している。
             """)
    
    st.subheader("2.1 攻撃耐性の評価手法")
    #　最大連結成分の割合、直径、平均経路長の中でなにをつかっていくか
    st.subheader("2.2.1 標的型攻撃における中心性再計算の必要性")
    # 再計算を伴う標的型攻撃と伴わない標的型攻撃を実際に比較し、それぞれ評価していく。
    st.subheader("2.2.2 pythonを用いたシュミレーション")
    # まともな実験は次回以降で！今回はお試し実験だけ！
    st.subheader("2.2.3 崩壊の判断基準")
    # わざわざノードが１つになるまで破壊しつくす必要はある？なにがわかればネットワークを破壊し終えた、と判断できる？
    st.subheader("2.3 プログラムの話")
    # networkx,igraph,matplotlib,graph-toolなど
    
    #次回は実験パート＋ロバストなネットワークはなにか紹介します。
    